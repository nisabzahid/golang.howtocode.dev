# ফাংশন

একটা ফাংশন কোনো আর্গুমেন্ট নিতে পারে নাও নিতে পারে। একটা নরমাল ফাংশনের উদাহরণ দেখি:

```go
package main

import "fmt"

func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(7, 6))
}
```

আউটপুট:  
‍\`\`\` 13

```text
এখানে `add` ফাংশনটি দুটো আর্গুমেন্ট নেয়। `x` এবং `y` দুটোই ইন্টিজার। এটাকে সংক্ষেপে এভাবেও লিখা যায়:  

```go
func add(x, y int) int {
    return x + y
}
```

অর্থাৎ `(x int, y int)` কে `(x, y int)` এভাবে। আর রিটার্ন টাইপ এর পরে। এই ফাংশন `int` টাইপের ভ্যালু রিটার্ন করে। একটা ফাংশন মাল্টিপল ভ্যালু রিটার্ন করতে পারে। যেমন:

```go
func swap(x, y string) (string, string) {
    return y, x
}
```

অর্থাৎ এটা দুটো স্ট্রিং নিয়ে সোয়াপ করে তাদের রিটার্ন করবে। আবার named রিটার্ন ভ্যালু ব্যবহার করা যায়। এক্ষেত্রে শুধু কোন কোন ভ্যারিয়েবল রিটার্ন হবে সেটা বলে দিতে হয় রিটার্ন টাইপের জায়গায়, টাইপসহ। শুধু `return` স্টেটমেন্ট ব্যবাহর করতে হয় এক্ষেত্রে। এটাকে বলে `"naked" return`। উপরের `add` ফাংশনটি এভাবে লিখা যায়:

```go
func add(x, y int) (sum int) {
    sum = x + y
    return
}
```

একটা ফাংশন মাল্টিপল ডাটা রিটার্ন করলে সেগুলোকে মাল্টিপল ভেরিয়েবল এ রাখা যায়। যেমন `divide` ফাংশনটি এভাবে লিখা যায়:

```go
func divide(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("division by zero is not allowed")
	}
	return a / b, nil // nil indicates no error
}

result, err := divide(10, 2)
```
এখানে রেজাল্ট আর এরর দুই ভেরিয়েবল এ ফাঙ্কশন এর রেসালট আর এরর ডাটা রাখা যায়। 
